#include <iostream>
#include <algorithm>
#include <cstdlib>

void print_int(int x) {
	std::cout << x << " ";
}

//хотя в языке Си и возможно использование функций с окружением, механизм пораждает множество ошибок:
//неверно переданные адреса окружения или путаница во времени жизни окружения

//С++ решает данную проблему посредством объектов!
//Объекты - это наборы функций, называемых методами или компонентами, которые объединены общим окружением, внутренними данными

//Попробуем переписать пример с заполнением массива случайными числами в диапазоне посредством механизма объектов

//Удобство объектов в том, что функции, использующие окружение, описываются в одном блоке с данными
struct RandInRange {
	int min, max; //данные называются "внутренними данными" или "полями", говорят, что у объекта есть два поля: min и max

	//это компонент-функция или метод, метод может использовать данные из окружения
	int operator() () { //для использования в стандартных алгоритмах мы должны объявить специальную функцию, котоаря называется оператором, она позволяет выполнять код, приписывая к переменной круглые скобки
		return rand() % (max - min + 1) + min;
	}
};

void randinrange_object_test() {
	//сначала мы должны "создать объект" на основе структуры, описанной выше
	//это делается также, как и создание переменной с типом структура
	RandInRange generator = { 0,100 }; //generator - это переменная, которая хранит внутри окружение, такая переменная называется объектом или экземпляром
	
	//Вызвать функцию operator() из описания структуры RandInRange невозможно без явного указания объекта, который предоставит ей свои данные
	//в данном случае приписывать круглые скобки можно к переменной generator
	srand(30023);
	std::cout << generator() << std::endl; //выводит на экран случайное число в диапазоне

	//мы можем создавать разные объекты, т.е. создавать разные окружения
	RandInRange generator2 = { -50,0 };
	std::cout << generator2() << std::endl; //выводит случайное число из другого диапазона

	//и в случае generator, и в случае generator2 вызывается одна и та же функция, описанная в стукруре

	//Используем объекты для заполнения массива случайными числами в диапазоне
	int random_arr1[10], random_arr2[10];
	std::generate(random_arr1, random_arr1 + 10, generator);//в качестве последнего параметра передаём объект
	std::generate(random_arr2, random_arr2 + 10, generator2);

	std::for_each(random_arr1, random_arr1 + 10, print_int); std::cout << std::endl;
	std::for_each(random_arr2, random_arr2 + 10, print_int); std::cout << std::endl;
}

//использование объектов значительно облегчает использование полиморфных алгоритмов
//построение программ на основе объектов называют объектно-ориентированным программированием

//объекты также могут служить средством объединения большого числа функций, связанных общим окружением
//такой подход эффективно используется для моделирования сущностей реального мира функциями

//описание стека объектом

struct Stack {
	char arr[100]; //символы, которые мы храним в стеке, внутренние данные
	int top; //положение верхушки стека

	bool push(char ch) { //функция добавления данных в стек, она использует данные из объекта, окружения
		if (100 == top) return false;
		arr[top++] = ch;
		return true; //возвращаемое значение сигнализирует об успешности операции
	}

	bool pop(char &ch) {
		if (0 == top) return false;
		ch = arr[--top];
		return true;
	}

	bool is_empty() {
		return 0 == top;
	}
};

void object_stack_test() {
	//решим задачу на верную скобочную конструкцию, используя объект-стек
	Stack symbol_stack = { {0}, 0 }; //инициализируем внутренние данные объекта

	char str[100]; //строка
	std::cin >> str;

	bool right = true, good = true;
	char *it = str;
	while (0 != *it) {
		if ('(' == *it || '[' == *it || '{' == *it) {
			if (!(good = symbol_stack.push(*it))) break; //функция-компонент вызывается через точку, как декомпозиция dot syntax
		}
		else if (')' == *it || ']' == *it || '}' == *it) {
			if (symbol_stack.is_empty()) {
				right = false;
				break;
			}

			char pair;
			symbol_stack.pop(pair);

			switch (*it) {
			case ')':
				right = '(' == pair;
				break;
			case ']':
				right = '[' == pair;
				break;
			case '}':
				right = '{' == pair;
				break;
			}

			if (!right) break;
		}
		++it;
	}

	right = right && symbol_stack.is_empty();

	if (!good) {
		std::cout << "Error with stack..." << std::endl;
		return;
	}

	if (!right) {
		std::cout << "Wrong bra-ket syntax!" << std::endl;
		return;
	}

	std::cout << "Good braket string" << std::endl;
}


int main() {
	if (false) randinrange_object_test();
	if (false) object_stack_test();

	return 0;
}
