#include <iostream>

//Для начала рассмотрим рекурсивные шаблоны
//Например, представим себе, что мы хотим написать функцию, которая высчитывает факториал числа
//Пусть эта функция будет шаблонной, где параметр шаблона - это число, от которого мы хотим посчитать факториал

template <size_t num>
size_t tpl_factorial(); //функция не имеет входящего параметра, т.к. мы его перенесли в параметр шаблона

//Как нам реализовать такую функцию рекурсивно?
//Нужно воспользоваться правилом n! = n*(n-1)!

template <size_t num>
size_t tpl_factorial() {
	return num * tpl_factorial<num - 1>(); //вместо передачи параметра в функцию, мы создаём новую функцию с другим параметром шаблона
}

//Как оргранизовать базу рекурсии?
//мы бы могли поставить условие:
//if (1 == num) return 1;
//Но можно воспользоваться тем, что при наличии специализации компилятор выберет именно её, а не общий шаблон
template<>
size_t tpl_factorial<1>() {
	return 1;
}

void tpl_factorial_test() {
	std::cout << tpl_factorial<5>() << std::endl;
}

int main() {
	if (false) tpl_factorial_test();

	return 0;
}