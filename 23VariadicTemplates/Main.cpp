#include <iostream>

//Для начала рассмотрим рекурсивные шаблоны
//Например, представим себе, что мы хотим написать функцию, которая высчитывает факториал числа
//Пусть эта функция будет шаблонной, где параметр шаблона - это число, от которого мы хотим посчитать факториал

template <size_t num>
size_t tpl_factorial(); //функция не имеет входящего параметра, т.к. мы его перенесли в параметр шаблона

//Как нам реализовать такую функцию рекурсивно?
//Нужно воспользоваться правилом n! = n*(n-1)!

template <size_t num>
size_t tpl_factorial() {
	return num * tpl_factorial<num - 1>(); //вместо передачи параметра в функцию, мы создаём новую функцию с другим параметром шаблона
}

//Как оргранизовать базу рекурсии?
//мы бы могли поставить условие:
//if (1 == num) return 1;
//Но можно воспользоваться тем, что при наличии специализации компилятор выберет именно её, а не общий шаблон
template<>
size_t tpl_factorial<1>() {
	return 1;
}

void tpl_factorial_test() {
	std::cout << tpl_factorial<5>() << std::endl;
}

//Этот искусственный пример демонстрирует возможность определения функций посредством рекурсии по параметру шаблона

//Этот принцип используется при создании шаблонов с переменным числом аргументов
//Давайте рассмотрим задачу: написать функцию, которая находит максимум из произвольного числа аргументов

//Мы легко можем написать функцию, которая находит максимум из двух аргументов
template <typename T>
auto my_max(T const &lha, T const &rha) { return lha > rha ? lha : rha; }

//Мы даже могли бы написать перегруженный вариант шаблона для трёх параметров
template <typename T>
auto my_max(T const &first, T const &second, T const &third) { return my_max(first, my_max(second, third)); }

//Шаблон написания функции для четырёх аргументов понятен: вложенные вызовы my_max с двумя аргументами
//Можем ли мы как-то организовать этот шаблон для произвольного числа входящих параметров?
//Да, для этого потребуется специальный синтаксис
//template <typename... Types>, где typename... - это так называемый "пак" несколько параметров, упакованных в общее имя
#include <array>
template<typename T, typename... Types>
auto my_max(Types... args) {
	//мы можем "распаковать" их в массив
	std::array<T, sizeof...(Types)> args_as_array = { args... };
	auto curr_max = args_as_array[0];
	for (auto &el : args_as_array)
		curr_max = my_max(el, curr_max);
	return curr_max;
}

void array_unpack_test() {
	std::cout << my_max<int>(7, -2, 3, -1, 0, 5) << std::endl;
}
//если у нас есть фиксированный набор элементов, то мы можем не сохранять их в контейнер, а вызвать функцию с произвольным числом аргументов

//Приведённый выше механизм действует только в тех случаях, когда типы данных одинаковы, 
//если они были бы различны, то распаковка в массив была бы невозможна

//Представим себе задачу: напечатать на экране произвольное число параметров неизвестного типа
//Здесь нам потребуется применить рекурсивный подход!
//База рекурсии очевидна
template <typename T>
void print_any(T arg) {
	std::cout << arg;
}

//Шаг рекурсии - это переход от функции с N параметрами, к фунции с N-1 параметром
template <typename First, typename... Rest> //First - это первый параметр шаблона, а ... Rest - это всё, что после него
void print_any(First arg, Rest... args) {
	print_any(arg); //печатаем первый аргумент, здесь срабатывает правило: точный список лучше пака
	print_any(args...);//печатем всё, что осталось
}

void print_any_test() {
	print_any("Hello ", 42, " World", '!', 3.1415);
}


int main() {
	if (false) tpl_factorial_test();
	if (false) array_unpack_test();
	if (false) print_any_test();

	return 0;
}