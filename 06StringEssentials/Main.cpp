#include <iostream>
#include <string>

//работа со строками €зыка —и очень сложна и требует крайней аккуратности
//во многом из-за того, что требует работы с пам€тью вручную
//—++ решает эту проблему за счЄт ќќѕ и деструкторов
void construct_string() {
	std::string s1; //пуста€ строка
	std::string s2('a', 10); //строка длиной 10, заполненна€ символом 'a'
	std::string s3("Hello World!"); //создание строки —++ из массива символов, завершаемого нулЄм
	std::string s4(s3); //копи€ строки s3

	//каждое создание строки требует динамической пам€ти,
	//при выходе строки из области видимости пам€ть будет освобождена деструктором

	//строки устроены таким образом, что могут быть выведены на экран через оператор вывода
	std::cout << "s1: " << s1 << "\ns2: " << s2 << "\ns3: " << s3 << "\ns4: " << s4 << std::endl;

	//как и массивы символов, строки можно заполн€ть с клавиатуры
	std::string in;
	std::cin >> in;
	std::cout << "in: " << in;

	//метод get объекта std::cin позвол€ет читать данные в массив-буфер
	char buff[100];
	std::cin.get(buff, 100, '\n');//прочесть не более 99 символов до '\n' (перевода строки)

	//функци€ std::getline читает данные в стандартную строку std::string
	std::string in2;
	std::getline(std::cin, in2, '\n'); //чтение данных в стандартную строку
	//количество необходимой пам€ти определ€етс€ автоматически
}

//доступ к элементам строки, символам
void accessing_string() {
	std::string s("Hello String!");

	//доступ к элементам строки осуществл€етс€ методами at и []
	for (std::string::size_type pos = 0; pos != s.size(); ++pos)
		std::cout << s[pos] << "  " << s.at(pos) << std::endl;
	//разница между [] и .at состоит в том, что .at производит проверку выхода за пределы массива данных

	//есть возможность получить доступ к первому и последнему символам
	std::cout << s.front() << "<...>" << s.back() << std::endl;

	//при необходимости можно получить доступ к массиву внутренних данных
	//s.data()[1] = 'h';//—++ 17
	std::cout << s.c_str() << std::endl;
}

//строки можно сравнивать на точное совпадение между собой
void compare_string() {
	std::string s1("Abba");
	std::string s2("Bbba");

	std::cout << std::boolalpha << (s1 == s2) << " " << (s1 > s2) << " " << (s1 < s2) << std::endl;

	//можно использовать метод compare, который ведЄт с€еб€ идентично функции strcmp из €зыка —и
	std::string user_input;
	std::cin >> user_input;
	if (0 == user_input.compare(s1))
		std::cout << "Yes" << std::endl;
	else
		std::cout << "No" << std::endl;
}


int main() {
	if (false) construct_string();
	if (false) accessing_string();
	if (false) compare_string();

	return 0;
}