#include <iostream>

//хотя объектно-ориентированное программирование в первую очередь говорит об объектах,
//многие языки программирования ориентированы не на прямое описание объектов,
//а на описание "классов"
//класс - это описание объектов, которые имеют общие функции-компоненты, методы и общие внутренние данные

//классы в языке С++ можно определять с помощью ключевых слов struct и class
struct Car { //Car - название типа данных, на основе которого можно строить большое количество переменных
	//внутренние данные
	int fuel_capacity; 
	int fuel_rate_100; //расход бензина на 100 километров

	//метод, оперирует не только входящими данными, но и внутренними данными объекта, окружением
	int distance() {
		return fuel_capacity * 100 / fuel_rate_100;
	}
};

//использование объектов
void car_test() {
	//использование объектов аналогично работе со структурами

	Car small_car = { 30,5 }; //создание объекта с инициализацией внутренних данных
	Car sport_car; //создание объекта без инициализации
	sport_car.fuel_capacity = 100; //обращение ко внутренним данным посредством оператора декомпозиции .
	sport_car.fuel_rate_100 = 20;

	std::cout << "Small: " << small_car.distance() << std::endl; //обращение к методам также осуществляется оператором декомпозиции .
	std::cout << "Sport: " << sport_car.distance() << std::endl;
}

//Одно из важных понятий в ООП - Инкапсуляция
//1) Соединение функций, называемых методами, с окружением в единую языковую конструкцию - объект
//2) Ограничение доступа к данным окружения методов

//в примере с классом Car, объявленным с использованием ключевого слова struct, мы могли напрямую использовать внутренние данные, однако при определении класса с ключевым словом class это невозможно
class Point {
	int x, y;

	void move(int vx, int vy) {
		x += vx; y += vy;
	}
};

//попытка использовать объекты класса Point провалится
void point_class_test() {
	Point p; //объявление возможно
	//Point p2 = { 0,0 }; //инициализация прямым доступом невозможна!
	//p.x = 0; //присваивание прямым доступом невозможно!
	//p.y = 0;

	//p.move(1, 1); //вызов функции невозможен!
}

//если мы используем слово class для определения класса, то по умолчанию все данные и методы скрыты от возможного использования согласно принципу инкапсуляции
//чтобы открыть итересующие нас элементы нужно использовать ключевое слово public

class PublicPoint {
public: //public: называется модификатором доступа, всё, что идёт после модификатора public:, будет доступно для использования
	int x, y;

	void move(int vx, int vy) {
		x += vx; y += vy;
	}
};

void publicpoint_class_test() {
	PublicPoint p; //объявление возможно
	PublicPoint p2 = { 0,0 }; //инициализация прямым доступом невозможна!
	p.x = 0; //присваивание прямым доступом невозможно!
	p.y = 0;

	p.move(1, 1); //вызов функции невозможен!
	std::cout << p.x << " " << p.y << std::endl;
}

//существует три модификатора: public, private, protected
//public - разрешает использование, открывает
//private - запрещает использование, скрывает
//protected - запрещает, но разрешает наследникам (относится к понятию "наследование")

class MixedPoint {
private:
	int x, y; //внутренние данные недоступны!

public:
	void move(int vx, int vy) { //вызов метода доступен!
		x += vx; y += vy; //обратите внимание, что "закрытость" не распространяется на использование внутри методов
	}
};

//использование объектов класса MixedPoint по-прежнему невозможно...
void mixedpoint_class_test() {
	//MixedPoint p = { 0,0 }; //мы не можем инициализировать объект, экземпляр класса MixedPoint
	//p.x = 1; //и не можем задать внутренние данные
	//p.y = 1;

	MixedPoint p2;
	p2.move(1, 2); //неопределённое поведение - данные не были инициализированы и не могут быть прочитаны
}

//существует несколько способов инициализации внутренних данных объекта

//1) задать значения по умолчанию при объявлении
class DefaultPoint {
private:
	int x = 0, y = 0;

public:
	void move(int vx, int vy) {
		x += vx; y += vy;
	}

	void print() {
		std::cout << "(" << x << "," << y << ")" << std::endl;
	}
};

void defaultpoint_class_test() {
	//DefaultPoint p = { 0,0 }; //мы по-прежнему не можем инициализировать
	//p.x = 1; //или менять данные
	//p.y = 1;

	DefaultPoint p2; //но инициализация по умолчанию пройдёт успешно
	p2.move(1, 2); //значения переменным будут заданы и метод выполнится предсказуемо
	p2.print();
}

//2) методы акцессоры и методы мутаторы, геттеры и сеттеры
class GetSetPoint {
private:
	int x, y;

public:
	int getX() { return x; } //методы геттеры или акцессоры позволяют получить значения внутренних данных
	int getY() { return y; }

	void setX(int input) { x = input; } //методы cеттеры или мутаторы позволяют менять значения внутренних данных
	void setY(int input) { y = input; }

	void move(int vx, int vy) {
		x += vx; y += vy;
	}

	void print() {
		std::cout << "(" << x << "," << y << ")" << std::endl;
	}
};

void getsetpoint_class_test() {
	//GetSetPoint p = { 0,0 }; //данные закрыты и их нельзя инициализировать напрямую
	//p.x = 1; //или менять
	//p.y = 1;

	GetSetPoint p2; //мы можем создать экземпляр с неинициализированными данными
	p2.setX(0); p2.setY(0); //затем можем установить их методами-мутаторами
	std::cout << p2.getX() << " " << p2.getY() << std::endl; //или прочесть методами-акцессорами

	p2.move(1, 2); //мы легко можем вызывать и другие методы, после присваивания значений, не боясь ошибок
	p2.print();
}

//3)конструктор - специальный метод, который позволяет инициализировать данные
class ConstructPoint {
private:
	int x, y;

public:
	ConstructPoint(int in_x, int in_y) { //конструктор объявляется как метод, но без возвращаемого типа данных и его имя строго совпадает с именем класса!
		x = in_x;
		y = in_y;
	}

	void move(int vx, int vy) {
		x += vx; y += vy;
	}

	void print() {
		std::cout << "(" << x << "," << y << ")" << std::endl;
	}
};

void constructpoint_class_test() {
	//ConstructPoint p = { 0,0 }; //данные закрыты и их нельзя инициализировать напрямую
	//p.x = 1; //или менять
	//p.y = 1;

	ConstructPoint p(0, 0); //но можно инициализировать, передав значения в круглых скобках

	//ConstructPoint p2; //мы НЕ можем создавать неинициализированные объекты, если нами был объявлен конструктор
	
	p.move(1, 2);
	p.print();
}

//Конструктор в классе может быть не один
//Как и функции, методы в С++, включая конструкторы, могут быть перегружены. т.е. иметь одинаковое имя, но различные входящие параметры
class MultipleConstructorsPoint {
private:
	int x, y;

public:
	MultipleConstructorsPoint(int in_x, int in_y) { //конструктор принимает два параметра
		x = in_x;
		y = in_y;
	}

	//конструктор без параметров называют "конструктор по умолчанию"
	MultipleConstructorsPoint() { //конструктор не принимает ни одного параметра
		x = 0;
		y = 0;
	}

	void move(int vx, int vy) {
		x += vx; y += vy;
	}

	void print() {
		std::cout << "(" << x << "," << y << ")" << std::endl;
	}
};

void multipleconstructspoint_class_test() {
	MultipleConstructorsPoint p(1, 1); //конструктор с двумя параметрами вызывается с помощью круглых скобок
	MultipleConstructorsPoint p2; //конструктор без параметров вызывается без скобок

	p.print(); p2.print();
}


int main() {
	if (false) car_test();
	//if (false) point_class_test(); //намеренно написана с ошибкой!
	if (false) publicpoint_class_test();
	//if (false) mixedpoint_class_test(); //намеренно написана с ошибкой!
	if (false) defaultpoint_class_test();
	if (false) getsetpoint_class_test();
	if (false) constructpoint_class_test();
	if (false) multipleconstructspoint_class_test();

	return 0;
}